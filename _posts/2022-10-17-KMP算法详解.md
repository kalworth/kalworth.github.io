---
title : KMP算法详解
tags : c++
---
## 初识KMP算法
**KMP算法是为了解决什么问题？**  
看如下问题：  
*出自西安电子科技大学数据结构试题*  

![image](https://p.ananas.chaoxing.com/star3/origin/064918997485202c9f7a5687c7e267a3.png)  

首先我们要解决的问题就是找出第一个节点匹配位置  
朴素解法即为  
枚举原串`S`中的每个字符作为「发起点」，每次从原串的「发起点」和匹配串的「首位」开始尝试匹配：

匹配成功：返回本次匹配的原串「发起点」。  
匹配失败：枚举原串的下一个「发起点」，重新尝试匹配。  
图示如下：  
[![xD9Qzt.png](https://s1.ax1x.com/2022/10/17/xD9Qzt.png)](https://imgse.com/i/xD9Qzt)  
时间复杂度为O（m*n）  
m为串`S`的长度，n为`T`的长度  
那么有没有办法将该过程的时间复杂度压到O（m+n）呢？  
**KMP算法就解决了这个问题**
## KMP算法的解决思路  
KMP算法希望在只遍历一遍数组的情况下找到匹配位置，所以对于串`S`指针i，我们需要让其不发生回退  
实现思路如下

[![xD9LYd.png](https://s1.ax1x.com/2022/10/17/xD9LYd.png)](https://imgse.com/i/xD9LYd)  

我们利用模式串`T`本身的特性获得了在i处匹配失败时我们应该从哪里继续匹配的问题，而不必回溯指针i

那么如何找出匹配失败后的回退位置呢
这里我们就需要研究串`T`本身的性质